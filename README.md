# 🎄 Advent of Code 2019 🎄
Here's my take on the Advent of Code challenge 2019. Instead of choosing "the right tool for the job", I decided to go through a list of 25 different programming languages and solve the puzzle with the tool I got assigned.

Some of the programming languages I know by heart, others I had never tried and barely seen before this challenge. And some occasions were definitely a case of "the absolutely wrong tool for the job". So there's a BIG disclosure regarding code quality... 🙈🙈🙈

## Dec 1st: Forth
🔍First appeared 1970. Procedural, stack-oriented, reflective, concatenative.

There is also a solution to the puzzle written in C. (Step 1 and 2)

## Dec 2nd: Lisp (Step 1 and 2)
🔍First appeared 1958. Functional, procedural, reflective, meta. Influenced e.g. Erlang, Prolog, Forth, Haskell.

💡You can find information [here](https://lisp-lang.org/learn/getting-started/) about how to download and get started with Lisp.

Start the sbcl shell and run using the following command:

```lisp
(load "puzzle2-step1.lisp")
(start)
```

## Dec 3rd: PHP (Step 1 and 2)
🔍First appeared 1995. Imperative, functional, object-oriented, procedural.

## Dec 4th: Smalltalk (Squeak) (Step 1 and 2)
🔍First appeared 1972 (Squeak in 1996). Object-oriented with its own virtual machine, on which the code can be changed while the program is running.

💡Squeak can be [downloaded here](https://squeak.org/) and there is an outstanding aide-memoire to be found [here](https://wiki.squeak.org/squeak/5699).

## Dec 5th: Scala (Step 1 and 2)
🔍First appeared 2004. Functional, imperative, object-oriented. Running on the JVM.

💡A Scala tutorial can be found [here](https://www.tutorialspoint.com/scala/index.htm)

## Dec 6th: Julia (Step 1 and 2)
🔍First appeared 2012. Procedural, functional.

## Dec 7th: Elixir
🔍First appeared 2011. Functional, concurrent, distributed. Inspired by Ruby, Erlang, and Clojure. Builds on top of Erlang and is running on the BEAM.

💡Elixir comes with a detailed and well-written [documentation](https://hexdocs.pm/elixir)

## Dec 8th: Ruby (Step 1)
🔍First appeared 1995. Functional, imperative, object-oriented.

## Dec 9th: Erlang
🔍First appeared 1986. Concurrent, functional.

## Dec 10th: Lua (Step 1 and 2)
🔍First appeared 1993. Imperative, functional.

💡Lua can be tried online [here](https://www.lua.org/cgi-bin/demo)

## Dec 11th: R
🔍First appeared 1993. Multi-paradigm: Array, object-oriented, imperative, functional, procedural, reflective

## Dec 12th: Java (Step 1)
🔍First appeared 1995. Object-oriented (class-based), imperative.

## Dec 13th: C++
🔍First appeared 1985. Procedural, object-oriented. "Object-oriented C".

## Dec 14th: JavaScript (Step 1)
🔍First appeared 1995. Event-driven, functional, imperative, object-oriented.

## Dec 15th: Pony
🔍Object-oriented, actor-model, capabilities-secure, high-performance.

## Dec 16th: Haskell (Step 1)
🔍First appeared 1990. Functional.

## Dec 17th: Golang
🔍First appeared 2009. Concurrent, functional, imperative, object-oriented.

## Dec 18th: Prolog
💡SWI Prolog can be tried online here: [here](https://swish.swi-prolog.org)

## Dec 19th: Idris
🔍First appeared 2007. Functional with dependent types.

## Dec 20th: Objective-C
🔍First appeared 1984. Reflective, class-based object-oriented. Influenced by C and Smalltalk. 

## Dec 21th: Self 
🔍First appeared 1987. Object-oriented (prototype-based). Influenced by Smalltalk.

## Dec 22th: Python (Step 1)
🔍First appeared 1990. Functional, imperative, object-oriented, reflective.

## Dec 23th: Swift
🔍First appeared 2014. Multi-paradigm: protocol-oriented, object-oriented, functional, imperative, block-structured declarative.

## Dec 24th: C#
🔍First appeared 2000. Structured, imperative, object-oriented, event-driven, task-driven, functional, generic, reflective, concurrent.

## Dec 25th: C
🔍First appeared 1972. Imperative (procedural), structured. Influenced e.g. C++, Java, PHP, C#.

📚C Programming Language *(Brian W. Kernighan, Dennis M. Ritchie)*